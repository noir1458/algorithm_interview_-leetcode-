# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
팰린드롬 판단하는 문제, 대문자 경우 소문자로 변환해야 비교가 용이할거라고 생각함

# Approach
<!-- Describe your approach to solving the problem. -->
s를 한번 순회하면서 대문자,소문자,숫자 판단하고 대문자인경우 소문자로 변환 후 저장. 그다음에 펠린드롬인지 판단은 for문 돌리고 한쪽은 앞에서, 한쪽은 뒤에서 돌리면서 중간지점 도달시 중단

# Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
O(n)

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
O(n) 인데... s를 한번 저장하지말고, s 자체에서 투포인터로 옮기면서 isalnum, tolower 하면 O(1) 이 되네

# Code
```cpp []
class Solution {
public:
    bool isPalindrome(string s) {
        deque<char> v;
        for(auto e: s){
            if (is_digit_num(e)){
                char n = convert_lower(e);
                v.push_back(n);
            }
        }
        return is_palin(v);  
    }

    bool is_digit_num(char c){
        if ((('a' <= c) && (c <= 'z')) ||
         (('A' <= c) && (c <= 'Z')) ||
         (('0' <= c) && (c <= '9')))
            return true;
        return false;
    }

    char convert_lower(char c){
        if (('A' <= c) && (c <= 'Z')){
            return (c - 'A') + 'a';
        }
        return c;
    }

    bool is_palin(deque<char> & v){
        while(v.size() > 1){
            char c1 = v.front();
            char c2 = v.back();
            if (c1 != c2) return false;
            v.pop_front();
            v.pop_back();
        }
        return true;
    }
};
```

# isalnum, tolower 이용
```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        deque<char> v;
        for(auto e: s){
            if (isalnum(static_cast<unsigned char>(e))){
                char e2 = static_cast<unsigned char>(tolower(static_cast<unsigned char>(e)));
                v.push_back(e2);
            }
        }
        return is_palin(v);  
    }

    bool is_palin(deque<char> & v){
        for(int i=0;i<v.size()/2;i++){
            cout << v[i]<<v[v.size()-1-i];
            if (v[i] != v[v.size()-1-i]) return false;
        }
        return true;
    }
};
```
마지막 비교 부분은 투 포인터로도 ok  
cctype 헤더에 두 함수가 있다