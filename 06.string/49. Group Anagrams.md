# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
애너그램이 같은 문자끼리 묶어서 리스트에 넣으면 된다

# Approach
<!-- Describe your approach to solving the problem. -->
정렬해서 애너그램 같은지 판단하면 된다. 같은 애너그램이라면 키가 같도록 해서 딕셔너리에 넣는건데

# Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
N이 strs 길이, K는 가장 긴 문자열 길이라면  
O(N*KlogK)


- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
O(N*K) 모든 단어를 딕셔너리에 저장해야하므로 입력 데이터 크기만큼 공간이 필요

# Code
```python3 []
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for str in strs:
            d[''.join(sorted(list(str)))] = d.get(''.join(sorted(list(str))),[]) + [str]
        return [v for v in d.values()]
```
이게 내 풀이인데


```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = collections.defaultdict(list)
        for word in strs:
            anagrams[''.join(sorted(word))].append(word)
        return list(anagrams.values())
```
이게 더 빠른 풀이가 되네

왜 내가 작성한 위의 풀이가 더 느린가?  
리스트끼리 + 연산을 하면 기존 리스트의 모든 요소를 복사하여 새로운 리스트 객체를 만든다. 리스트마다 O(N)이 되어버림

appends()하면 O(1) (Amortized) 시간이 걸린다.

그리고 내 코드에서는 sorted()를 두번 하고있었네


```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for str in strs:
            sort_str = ''.join(sorted(list(str)))
            d[sort_str] = d.get(sort_str,[]).append()
        return [v for v in d.values()]
```
이런식으로 하고 있었는데, 틀린 이유를 분석해보면

append()는 None을 반환한다. 그걸 대입하고 있었다.

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for str in strs:
            sort_str = ''.join(sorted(list(str)))
            if sort_str not in d:
                d[sort_str] = []
            d[sort_str].append(str)
        return [v for v in d.values()]
```
이렇게 쓰였어야 한다. 그리고 defaultdict 쓰는걸 보통 권장하는것으로 보인다.