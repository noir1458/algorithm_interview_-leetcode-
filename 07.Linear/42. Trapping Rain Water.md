# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
배열로 벽이 주어질때 쌓일수 있는 물의 부피는?

# Approach
<!-- Describe your approach to solving the problem. -->
투포인터, 스택을 이용하는 방법이 있는데  
투포인터로 일단 풀었다. 이게 가장 좋은 풀이인듯

# Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
O(n), 양쪽에서 포인터가 다가오면서 배열을 훑는데, 좌우 어떤 인덱스가 지나가든 한번만 방문되고, 가운데 가장 높은데서 만나게 된다

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
O(1)

# Code
```python3 []
class Solution:
    def trap(self, height: List[int]) -> int:
        if len(height)==0:
            return 0
        
        volume = 0
        left, right=0, len(height)-1
        left_max = height[left]
        right_max = height[right]

        while(left < right):
            if left_max < right_max:
                left += 1
                left_max = max(height[left], left_max)
                volume += left_max - height[left]
            else:
                right -= 1
                right_max = max(height[right], right_max)
                volume += right_max - height[right]
        return volume
```
끝에서 출발에서 가장 높은 벽을 향해서 좁혀온다고 생각하면 된다